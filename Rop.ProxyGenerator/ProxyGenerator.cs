using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Rop.ProxyGenerator
{
    [Generator]
    public class ProxyGenerator : ISourceGenerator
    {
        private static readonly string[] _memberOverrideAtts=new string[]{"OverrideNoBase","OverrideNew","OverrideWithPreBase","OverrideWithPostBase"};
        private static readonly ImmutableHashSet<string> _memberOverrideAttsHash = _memberOverrideAtts.ToImmutableHashSet();
        private static readonly string[] _memberExplicitAtts=new string[]{"Explicit","ExplicitOverrideNoBase","ExplicitOverrideWithPreBase","ExplicitOverrideWithPostBase"};
        private static readonly ImmutableHashSet<string> _memberExplicitAttsHash = _memberExplicitAtts.ToImmutableHashSet();
        private static readonly ImmutableHashSet<string> _memberAllAttsHash = _memberOverrideAtts.Concat(_memberExplicitAtts).ToImmutableHashSet();

        private static readonly string[] _includeAttributesAtts=new string[]{"IncludeNextAttributes"};
        private static readonly ImmutableHashSet<string> _includeAttributesAttsHash= _includeAttributesAtts.ToImmutableHashSet();

        public void Initialize(GeneratorInitializationContext context)
        {
//#if DEBUG
//            if (!Debugger.IsAttached)
//            {
//                Debugger.Launch();
//            }
//#endif
            context.RegisterForSyntaxNotifications(() => new ProxyClassesToAugmentReceiver());

        }
        
        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ProxyClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, ProxyClassToAugment classtoaugment)
        {
            var file = classtoaugment.ClassToAugment.FileName +".Proxy_"+classtoaugment.InterfaceToProxy.InterfaceName.Name+".g.cs";
            var iname = classtoaugment.InterfaceToProxy.InterfaceName;
            var model = context.Compilation.GetSemanticModel(classtoaugment.ClassToAugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.ClassToAugment.Original);
            if (classmodel is null) return;
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for Proxy class");
            var i = classmodel.AllInterfaces.FirstOrDefault(ii =>iname.Equals(ii));
            if (i == null)
            {
                // ERROR NO MATCH PROXY
                sb.AppendLines("// ERROR NO MATCH PROXY",$"// Looking for:{iname.FullName}");
                sb.AppendLine($"// Candidates:");
                foreach (var classmodelAllInterface in classmodel.AllInterfaces)
                {
                    sb.AppendLine($"//\t{classmodelAllInterface}");
                }
                var finalerror = sb.ToString();
                context.AddSource(file, finalerror);
                return;
            }

            sb.AppendLines(classtoaugment.ClassToAugment.GetHeader(i));
            var symbols = i.GetOrderedMembers(true);
            foreach (var symbol in symbols)
            {
                var name = symbol.Name;
                var excludeatt = symbol.IsDecoratedWith("Exclude");
                if (excludeatt || classtoaugment.InterfaceToProxy.Excludes.Contains(name))
                {
                    sb.AppendLine();
                    sb.AppendLines(2,$"// Symbol '{name}' excluded");
                    sb.AppendLine();
                    continue;
                }

                switch (symbol)
                {
                    case IPropertySymbol propertySymbol:
                        augmentProperty(sb, propertySymbol,classtoaugment,i);
                        break;
                    case IMethodSymbol methodSymbol:
                        augmentMethod(sb, methodSymbol,classtoaugment,i);
                        break;
                    case IEventSymbol eventSymbol:
                        augmentEvent(sb, eventSymbol,classtoaugment,i);
                        break;
                }
            }
            sb.AppendLines(classtoaugment.ClassToAugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }
        private void augmentProperty(StringBuilder sb, IPropertySymbol prop,ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            var interfacename=classToAugment.InterfaceToProxy.InterfaceName.FullName;
            var includesetter=prop.GetDecoratedWith("AddSetterOnProxy")!=null;
            var specialatt = prop.GetDecoratedWith(_memberAllAttsHash);
            var isexplicit =(specialatt!=null)&& _memberExplicitAttsHash.Contains(specialatt.GetShortName());

            var includeatts = new IncludesAtts(prop);


            if (isexplicit)
                ExplicitProperty();
            else
                NoExplicitProperty();
            
            
            
            // Local Functions

            void NoExplicitProperty()
            {
                var aoverride = specialatt;
                var voro = GetOverrideString(aoverride);
                includeatts.Render(sb,2);
                sb.Append($"\t\tpublic {voro} {tipo} {name}");
                sb.Append("{");
                if (!prop.IsWriteOnly) sb.Append($" get=>{field}.{name};");
                if (!prop.IsReadOnly || includesetter) sb.Append($" set=>{field}.{name}=value;");
                sb.AppendLine("}");
            }

            void ExplicitProperty()
            {
                sb.Append($"\t\t{tipo} {prop}");
                sb.Append("{");
                if (!prop.IsWriteOnly) sb.Append($" get=>{field}.{name};");
                if (!prop.IsReadOnly) sb.Append($" set=>{field}.{name}=value;");
                sb.AppendLine("}");

                var includeoverride = specialatt.GetShortName() == "ExplicitOverrideNoBase";
                if (includeoverride)
                {
                    var thias = $"(this as {interfacename})";
                    includeatts.Render(sb,2);
                    sb.Append($"\t\tprotected override {tipo} {name}");
                    sb.Append("{");
                    if (!prop.IsWriteOnly) sb.Append($" get=>{thias}.{name};");
                    if (!prop.IsReadOnly) sb.Append($" set=>{thias}.{name}=value;");
                    sb.AppendLine("}");
                }
            }
        }

        private static string GetOverrideString(AttributeData aoverride)
        {
            return (aoverride == null) ? "virtual" : ((aoverride.GetShortName() == "OverrideNew") ? "new" : "override");
        }

        private void augmentEvent(StringBuilder sb, IEventSymbol prop,ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            var name = prop.Name;
            var tipo = prop.Type;
            var field = classToAugment.InterfaceToProxy.FieldName;
            sb.Append($"\t\tpublic event {tipo} {name}");
            sb.Append("{");
            sb.Append($" add=>{field}.{name}+=value;");
            sb.Append($" remove=>{field}.{name}-=value;");
            sb.AppendLine("}");
        }
        private void augmentMethod(StringBuilder sb, IMethodSymbol meth, ProxyClassToAugment classToAugment,INamedTypeSymbol i)
        {
            if (meth.MethodKind!=MethodKind.Ordinary) return;
            var name = meth.Name;
            var tipo = meth.ReturnType.ToString();
            var field = classToAugment.InterfaceToProxy.FieldName;
            var interfacename=classToAugment.InterfaceToProxy.InterfaceName.FullName;

            var specialatt = meth.GetDecoratedWith(_memberAllAttsHash);
            var isexplicit =(specialatt!=null)&& _memberExplicitAttsHash.Contains(specialatt.GetShortName());

            var includeatts = new IncludesAtts(meth);

            if (isexplicit)
            {
                ExplicitMethod();
            }
            else
            {
                NoExplicitMethod();
            }

            // Local Functions
            void MethodBody(bool prebase,bool postbase, string pnames , string retstr)
            {
                if (prebase)
                    sb.AppendLines(3,
                        $"base.{name}({pnames});");
                if (!postbase)
                    sb.AppendLines(3,
                        $"{retstr}{field}.{name}({pnames});");
                else
                    sb.AppendLines(3,
                        $"{field}.{name}({pnames});",
                        $"{retstr}base.{name}({pnames});");
            }

            void ExplicitMethod()
            {
                var aexplicit = specialatt;
                var nobase = aexplicit.GetShortName() == "ExplicitOverrideNoBase";
                var prebase = aexplicit.GetShortName() == "ExplicitOverrideWithPreBase";
                var postbase = aexplicit.GetShortName() == "ExplicitOverrideWithPostBase";

                var pdef =meth.GetParametersDefinition();
                var pnames = meth.GetParametersNames();

                var retstr = (tipo == "void") ? "" : "return ";
                var includeoverride = nobase | prebase | postbase;
                sb.AppendLines(2,
                    $"{tipo} {meth.ReceiverType}.{meth.Name}({pdef})",
                    "{");
                MethodBody(prebase, postbase, pnames, retstr);
                sb.AppendLines(2,
                    "}");

                if (includeoverride)
                {
                    var thisas = $"(this as {interfacename})";
                    includeatts.Render(sb,2);
                    sb.AppendLines(2,
                        $"protected override {tipo} {name}({pdef})",
                        "{");
                    sb.AppendLines(3, $"{retstr}{thisas}.{name}({pnames});");
                    sb.AppendLines(2,
                        "}");
                }
            }

            void NoExplicitMethod()
            {
                var aoverride = specialatt;
                var voro = GetOverrideString(aoverride);
                var prebase = aoverride.GetShortName() == "OverrideWithPreBase";
                var postbase = aoverride.GetShortName() == "OverrideWithPostBase";
                var pdef =meth.GetParametersDefinition();
                var pnames = meth.GetParametersNames();
                var retstr = (tipo == "void") ? "" : "return ";
                includeatts.Render(sb,2);
                sb.AppendLines(2,
                    $"public {voro} {tipo} {name}({pdef})",
                    "{");
                MethodBody(prebase, postbase, pnames, retstr);
                sb.AppendLines(2,
                    "}");
            }
        }

        class ProxyClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<ProxyClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<ProxyClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                // Business logic to decide what we're interested in goes here
                if (syntaxNode is ClassDeclarationSyntax cds && cds.IsDecoratedWith("ProxyOf"))
                {
                    var atts=cds.GetDecoratedWithSome("ProxyOf");
                    foreach (var att  in atts)
                    {
                        var ac = new ProxyClassToAugment(cds,att);
                        if (ac.InterfaceToProxy !=null) ClassesToAugment.Add(ac);
                    }
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<ProxyClassToAugment>();
            }
        }
    }

    public class IncludesAtts
    {
        public List<string> AttsToInclude { get; } = new List<string>();
        public IncludesAtts(ISymbol namedTypeSymbol)
        {
            var nextatts = namedTypeSymbol.GetAttributes().SkipWhile(a => a.GetShortName() != "IncludeNextAttributes")
                .ToList();
            if (nextatts.Any())
            {
                AttsToInclude.AddRange(nextatts.Skip(1).Select(a=>a.ToString()));
            }
        }

        public void Render(StringBuilder sb, int tabs)
        {
            foreach (var att in AttsToInclude)
            {
                sb.AppendLines(tabs,$"[{att}]");
            }
        }
        public bool IsEmpty => AttsToInclude.Count == 0;
    }
}
