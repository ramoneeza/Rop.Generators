using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Rop.Generators.Shared;

namespace Rop.ObservableGenerator
{
    [Generator]
    public class ObservableGenerator : ISourceGenerator
    {
        public const string AutoNotifyAttributeName = "AutoNotify";
        public const string AutoObservableAttributeName = "AutoObservable";
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassesToAugmentReceiver());
        }


        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ClassesToAugmentReceiver;
            if (collector==null || collector.ClassesToAugment.Count==0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
               generateCode(context, classtoaugment);
            }
            collector.Clear();
        }

        

        private void generateCode(GeneratorExecutionContext context, ProxyPartialClassToAugment proxyclasstoaugment)
        {
            var (classtoaugment, fields) = (proxyclasstoaugment.Original, proxyclasstoaugment.Fields);
            var classname=classtoaugment.Identifier;
            var file = classtoaugment.FileName +"."+classname+".Observables.g.cs";
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for "+classname);
            sb.AppendLines(classtoaugment.GetHeader());
            foreach (var thefield in fields)
            {
                var originalfieldname = thefield.FieldName;
                var finalName= thefield.FinalName;
                var att = thefield.Attribute;
                if (att.Name.ToString() == AutoObservableAttributeName)
                {
                    sb.AppendLine($"\t\tpublic {thefield.Field.Declaration.Type.ToString()} {finalName} {{");
                    sb.AppendLine($"\t\t\tget =>{originalfieldname};");
                    sb.AppendLine($"\t\t\tset {{");
                    sb.AppendLine($"\t\t\t\tif ({originalfieldname}==value) return;");
                    sb.AppendLine($"\t\t\t\t{originalfieldname}=value;");
                    sb.AppendLine($"\t\t\t\tOn{finalName}Changed();");
                    sb.AppendLine($"\t\t\t}}");
                    sb.AppendLine($"\t\t}}");
                    var skip = false;
                    if (att.ArgumentList?.Arguments.Any() ?? false)
                    {
                        var a=att.ArgumentList.Arguments.First();
                        var arg=a.Expression.ToString();
                        if (arg=="true") skip = true;
                    }
                    if (!skip)
                    {

                        sb.AppendLine($"\t\tpublic event EventHandler? {finalName}Changed;");
                        sb.AppendLine($"\t\tprotected virtual void On{finalName}Changed()");
                        sb.AppendLine($"\t\t{{");
                        if (thefield.Method != null)
                        {
                            sb.AppendLine($"\t\t\t{thefield.Method.Identifier.ToString()}();");
                        }
                        sb.AppendLine($"\t\t\t{finalName}Changed?.Invoke(this,EventArgs.Empty);");
                        sb.AppendLine($"\t\t}}");
                    }

                };
                if (att.Name.ToString() == AutoNotifyAttributeName)
                {
                    sb.AppendLine($"\t\tpublic {thefield.Field.Declaration.Type.ToString()} {finalName} {{");
                    sb.AppendLine($"\t\t\tget =>{originalfieldname};");
                    sb.AppendLine($"\t\t\tset {{");
                    sb.AppendLine($"\t\t\t\tif ({originalfieldname}==value) return;");
                    sb.AppendLine($"\t\t\t\t{originalfieldname}=value;");
                    sb.AppendLine($"\t\t\t\tOnPropertyChanged(nameof({finalName}));");
                    sb.AppendLine($"\t\t\t}}");
                    sb.AppendLine($"\t\t}}");
                }
            }



            sb.AppendLines(classtoaugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }
        
        

        class ClassesToAugmentReceiver : ISyntaxReceiver
        {
            
            public TraceSource Ts { get; } = new TraceSource("ObservableGenerator", SourceLevels.All);
            public ConcurrentBag<ProxyPartialClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<ProxyPartialClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax cds)) return;
                // Business logic to decide what we're interested in goes here
                // get children of type field declaration
                var fields = cds.ChildNodesOfType<FieldDeclarationSyntax>()
                    .Where(f => f.IsDecoratedWith(AutoObservableAttributeName,AutoNotifyAttributeName));

                var changemethods=cds.ChildNodesOfType<MethodDeclarationSyntax>().Where(m => m.Modifiers.Any(mm=>mm.ToString()=="private" && m.Identifier.ToString().StartsWith("_on") && m.Identifier.ToString().EndsWith("Changed"))).ToList();
                var resfields=new List<FieldToAugment>();
                foreach (var f in fields)
                {
                    var d = f.GetDecoratedWithAny(AutoObservableAttributeName, AutoNotifyAttributeName);
                    if (d.Length!=1) continue;

                    var ftoau = new FieldToAugment(f, d[0],null);
                    var finalname= ftoau.FinalName;
                    var desiredmethod="_on"+finalname+"Changed";
                    var m = changemethods.FirstOrDefault(mm => mm.Identifier.ToString() == desiredmethod);
                    ftoau.Method = m;
                    resfields.Add(ftoau);
                }
                var fields2=resfields.ToArray();
                if (fields2.Length!=0) ClassesToAugment.Add(new ProxyPartialClassToAugment(new PartialClassToAugment(cds),fields2));
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<ProxyPartialClassToAugment>();
            }

        }
    }

    
}
