using System.Collections.Concurrent;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Rop.GeneratorHelper;

namespace Rop.Winforms7.StaticExtensionGenerator
{
    [Generator]
    public class StaticExtensionGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
//#if DEBUG
//            if (!Debugger.IsAttached)
//            {
//                Debugger.Launch();
//            }
//#endif
            context.RegisterForSyntaxNotifications(() => new ClassesToAugmentReceiver());
        }
        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment,collector);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, ProxyPartialClassToAugment proxyclasstoaugment,ClassesToAugmentReceiver receiver)
        {
            var (classtoaugment, extensiontoinclude) = (proxyclasstoaugment.Original, proxyclasstoaugment.ExtensionNameType);

            var formname=classtoaugment.Identifier;
            var flatextensionname = SyntaxHelper.FlatTypeName(extensiontoinclude.ToString());

            var file = classtoaugment.FileName +".Extension."+flatextensionname+"_.g.cs";
            var model = context.Compilation.GetSemanticModel(classtoaugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.Original);
            var info = model.GetSymbolInfo(extensiontoinclude);
            var extensionmodels=(info.Symbol as IMethodSymbol);
            var extensionmodela = (extensionmodels?.ReceiverType) as INamedTypeSymbol;
            var extensionmodel = extensionmodela?.TypeArguments[0];
            if (classmodel is null || extensionmodel is null) return;
            
            var methods = extensionmodel.GetMembers().OfType<IMethodSymbol>().Where(x => x.MethodKind == MethodKind.Ordinary && x.IsStatic).ToList();

            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for Controllers");
            if (methods.Count == 0)
            {
                // ERROR NO EXTENSIONS
                sb.AppendLines("// ERROR NO EXTENSIONS",$"// Looking for:{classtoaugment.Identifier}");
                var finalerror = sb.ToString();
                context.AddSource(file, finalerror);
                return;
            }
            sb.AppendLines(classtoaugment.GetHeader(new string []{}));
            foreach (var symbol in methods)
            {
                var name = symbol.Name;
                var returntype = symbol.ReturnType.Name;
                var par=symbol.Parameters;
                var pardef=string.Join(",",par.Select(p=>p.ToString()));
                var parnames =string.Join(",",par.Select(p => p.Name));

                sb.AppendLines($"\t\tpublic static {returntype} {name}({pardef})=>{extensionmodel.ToDisplayString()}.{name}({parnames});");
            }
            
            sb.AppendLines(classtoaugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }
        
        class ClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<ProxyPartialClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<ProxyPartialClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax cds)) return;
                // Business logic to decide what we're interested in goes here
                var atts=cds.GetDecoratedWithSomeGeneric("StaticExtension");
                if (atts.Any())
                {
                    var ac = new PartialClassToAugment(cds);
                    foreach (var a in atts)
                    {
                        var t = a.Name as GenericNameSyntax;
                        if (t == null) continue;
                        var proxy = new ProxyPartialClassToAugment(ac, t);
                        ClassesToAugment.Add(proxy);
                    }
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<ProxyPartialClassToAugment>();
            }
        }
    }

    
}
