using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Rop.Generators.Shared;

namespace Rop.Winforms7.StaticExtensionGenerator
{
    [Generator]
    public class StaticExtensionGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassesToAugmentReceiver());
        }
        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment,collector);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, PartialClassToAugment classtoaugment,ClassesToAugmentReceiver receiver)
        {
            var formname=classtoaugment.Identifier;
            var file = classtoaugment.FileName +".StaticExtensions_.g.cs";
            var model = context.Compilation.GetSemanticModel(classtoaugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.Original);
            if (classmodel is null) return;
            var baseclase=classmodel.BaseType;
            var staticMethods=GetStaticMethods(baseclase,classmodel,model,receiver);
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for StaticMethods");
            if (staticMethods.Count == 0)
            {
                // ERROR NO EXTENSIONS
                sb.AppendLines("// ERROR NO EXTENSIONS",$"// Looking for:{classtoaugment.Identifier}");
                var finalerror = sb.ToString();
                context.AddSource(file, finalerror);
                return;
            }
            sb.AppendLines(classtoaugment.GetHeader(new string []{}));
            foreach (var symbol in staticMethods)
            {
                var name = symbol.Name;
                var returntype = symbol.ReturnType.OriginalDefinition.ToString();
                var par=symbol.Parameters;
                var pardef=string.Join(",",par.Select(p=>p.ToString()));
                var parnames =string.Join(",",par.Select(p => p.Name));
                var clasebelongs=symbol.ContainingType;
                sb.AppendLines($"\t\tpublic static {returntype} {name}({pardef})=>{clasebelongs.ToDisplayString()}.{name}<{formname}>({parnames});");
            }
            sb.AppendLines(classtoaugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }

        private List<IMethodSymbol> GetStaticMethods(INamedTypeSymbol baseclase, INamedTypeSymbol classmodel, SemanticModel model, ClassesToAugmentReceiver receiver)
        {
            var res=new List<IMethodSymbol>();
            var bc=baseclase.BaseType;
            if (bc != null && bc.Name != "Object")
            {
                var preres = GetStaticMethods(bc, classmodel, model, receiver);
                res.AddRange(preres);
            }

            var staticMethods = baseclase.GetMembers().Where(m => m.Kind == SymbolKind.Method && m.IsStatic && m.IsDecoratedWith("StaticExtension")).OfType<IMethodSymbol>().ToList();
            foreach (var method in staticMethods)
            {
                if (!method.IsGenericMethod) continue;
                var a=method.TypeParameters[0];
                var constraints = a.ConstraintTypes[0].Name;
                if (!constraints.StartsWith(baseclase.Name)) continue;
                res.Add(method);
            }
            return res;
        }

        class ClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<PartialClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<PartialClassToAugment>();
            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax cds)) return;
                // Business logic to decide what we're interested in goes here
                var att=cds.GetDecoratedWith("InsertStaticExtensions");
                if (att!=null)
                {
                    var ac = new PartialClassToAugment(cds);
                    ClassesToAugment.Add(ac);
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<PartialClassToAugment>();
            }
        }
    }

    
}
