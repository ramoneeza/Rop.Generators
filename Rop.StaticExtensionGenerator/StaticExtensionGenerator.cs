using System.Collections.Concurrent;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Rop.Generators.Shared;

namespace Rop.Winforms7.StaticExtensionGenerator
{
    [Generator]
    public class StaticExtensionGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ClassesToAugmentReceiver());
        }
        public void Execute(GeneratorExecutionContext context)
        {
            var collector = context.SyntaxReceiver as ClassesToAugmentReceiver;
            if (collector == null || collector.ClassesToAugment.Count == 0) return;
            foreach (var classtoaugment in collector.ClassesToAugment)
            {
                generateCode(context, classtoaugment,collector);
            }
            collector.Clear();
        }
        private void generateCode(GeneratorExecutionContext context, PartialClassToAugment classtoaugment,ClassesToAugmentReceiver receiver)
        {
            var formname=classtoaugment.Identifier;
            var file = classtoaugment.FileName +".StaticExtensions_.g.cs";
            var model = context.Compilation.GetSemanticModel(classtoaugment.Original.SyntaxTree);
            var classmodel = (INamedTypeSymbol)model.GetDeclaredSymbol(classtoaugment.Original);
            if (classmodel is null) return;
            var baseclase=classmodel.BaseType;
            if (baseclase is null||baseclase.Name=="Object")
            {
                var iderived=classmodel.Interfaces.FirstOrDefault(i=>i.Name=="IDerivedFrom" || i.Name=="IFormDerivedFrom");
                if (iderived != null)
                {
                    baseclase= iderived.TypeArguments[0] as INamedTypeSymbol;
                }
            }
            var (staticMethods,path)=GetStaticMethods(baseclase,classmodel,model,receiver);
            var sb = new StringBuilder();
            sb.AppendLine("// Autogenerated code for StaticMethods");
            sb.AppendLine("// Object Path: " + path);
            if (staticMethods.Count == 0)
            {
                // ERROR NO EXTENSIONS
                sb.AppendLines("// ERROR NO EXTENSIONS",$"// Looking for:{classtoaugment.Identifier}");
                var finalerror = sb.ToString();
                context.AddSource(file, finalerror);
                return;
            }
            sb.AppendLines(classtoaugment.GetHeader(new string []{}));
            foreach (var symbol in staticMethods)
            {
                var prename = symbol.Name;
                var name = prename;
                if (name.StartsWith("_")) name = name.Substring(1);
                if (char.IsLower(name[0])) name = char.ToUpper(name[0]) + name.Substring(1);
                var returntype = symbol.ReturnType.ToString();
                var par=symbol.Parameters;
                var pardef=string.Join(",",par.Select(p=>p.ToString()));
                var parnames =string.Join(",",par.Select(p => p.Name));
                var clasebelongs=symbol.ContainingType;
                sb.AppendLines($"\t\tpublic static {returntype} {name}({pardef})=>{clasebelongs.ToDisplayString()}.{prename}<{formname}>({parnames});");
            }
            sb.AppendLines(classtoaugment.GetFooter());
            var final = sb.ToString();
            context.AddSource(file, final);
        }

        private (List<IMethodSymbol>,string) GetStaticMethods(INamedTypeSymbol baseclase, INamedTypeSymbol classmodel, SemanticModel model, ClassesToAugmentReceiver receiver)
        {
            var res=new List<IMethodSymbol>();
            var path = "";
            if (receiver.DictionaryOfMethods.TryGetValue(baseclase.ToDisplayString(), out var tmethods))
            {
                return tmethods;
            }

            try
            {
                var bc = baseclase.BaseType;
                path = bc?.ToDisplayString()??"";
                if (bc != null && bc.Name != "Object")
                {
                    var preres = GetStaticMethods(bc, classmodel, model, receiver);
                    res.AddRange(preres.Item1);
                    path = path+"-->"+preres.Item2;
                }
                var staticMethods = baseclase.GetMembers()
                    .Where(m => m.Kind == SymbolKind.Method && m.IsStatic && m.IsDecoratedWith("StaticExtension"))
                    .OfType<IMethodSymbol>().ToList();
                foreach (var method in staticMethods)
                {
                    if (!method.IsGenericMethod) continue;
                    var a = method.TypeParameters[0];
                    var constraints = a.ConstraintTypes[0].Name;
                    if (constraints!=baseclase.Name) continue;
                    res.Add(method);
                }
                receiver.DictionaryOfMethods.Add(baseclase.ToDisplayString(), (res,path));
                return (res,path);
            }
            catch (System.Exception ex)
            {
                return (new List<IMethodSymbol>(),"*Error:"+ex.Message);
            }
        }

        class ClassesToAugmentReceiver : ISyntaxReceiver
        {
            public ConcurrentBag<PartialClassToAugment> ClassesToAugment { get; private set; } = new ConcurrentBag<PartialClassToAugment>();
            public Dictionary<string,(List<IMethodSymbol>,string)> DictionaryOfMethods { get; private set; } = new Dictionary<string, (List<IMethodSymbol>, string)>();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                if (!(syntaxNode is ClassDeclarationSyntax cds)) return;
                // Business logic to decide what we're interested in goes here
                var att=cds.GetDecoratedWith("InsertStaticExtensions");
                if (att!=null)
                {
                    var ac = new PartialClassToAugment(cds);
                    ClassesToAugment.Add(ac);
                }
            }
            public void Clear()
            {
                ClassesToAugment = new ConcurrentBag<PartialClassToAugment>();
                DictionaryOfMethods = new Dictionary<string, (List<IMethodSymbol>, string)>();
            }
        }
    }

    
}
